{"version":3,"sources":["wepy.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n// can we use __proto__?\nfunction getHasProto() {\n  var hasProto = false;\n  if ('__proto__' in {}) {\n    var fn = function () {};\n    var arr = [];\n    arr.__proto__ = { push: fn };\n    hasProto = fn === arr.push;\n  }\n  return hasProto;\n}\nvar hasProto = getHasProto();\n\nvar _Set; // $flow-disable-line\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\n/**\n * String type check\n */\nvar isStr = function (v) { return typeof v === 'string'; };\n/**\n * Number type check\n */\nvar isNum = function (v) { return typeof v === 'number'; };\n/**\n * Array type check\n */\nvar isArr = Array.isArray;\n/**\n * undefined type check\n */\nvar isUndef = function (v) { return v === undefined; };\n/**\n * Function type check\n */\nvar isFunc = function (v) { return typeof v === 'function'; };\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n\nvar isObj = isObject;\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar _toString = Object.prototype.toString;\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\n// eslint-disable-next-line\nfunction noop(a, b, c) {}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\n/**\n * Convert an Array-lik object to a real Array\n */\nfunction toArray(list, start) {\n  if ( start === void 0 ) start = 0;\n\n  var i = list.length - start;\n  var rst = new Array(i);\n  while (i--) {\n    rst[i] = list[i + start];\n  }\n  return rst;\n}\n\n/**\n * Cached simply key function return\n */\nvar cached = function (fn) {\n  var cache = {};\n  return function (str) { return cache[str] || (cache[str] = fn(str)); };\n};\n\nvar camelizeRE = /-(\\w)/g;\n\n/**\n * camelize words\n * e.g. my-key => myKey\n */\nvar camelize = cached(function (str) { return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); }); });\n\n/*\n * extend objects\n * e.g.\n * extend({}, {a: 1}) : extend {a: 1} to {}\n * extend(true, [], [1,2,3]) : deep extend [1,2,3] to an empty array\n * extend(true, {}, {a: 1}, {b: 2}) : deep extend two objects to {}\n */\nfunction extend() {\n  var arguments$1 = arguments;\n\n  var options,\n    name,\n    src,\n    copy,\n    copyIsArray,\n    clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if (typeof target === 'boolean') {\n    deep = target;\n\n    // Skip the boolean and the target\n    target = arguments[i] || {};\n    i++;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== 'object' && !(typeof target === 'function')) {\n    target = {};\n  }\n\n  // Extend jQuery itself if only one argument is passed\n  if (i === length) {\n    target = this;\n    i--;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments$1[i])) {\n      // Extend the base object\n      for (name in options) {\n        src = target[name];\n        copy = options[name];\n\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && Array.isArray(src) ? src : [];\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[name] = extend(deep, clone, copy);\n\n          // Don't bring in undefined values => bring undefined values\n        } else {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n}\n\n/*\n * clone objects, return a cloned object default to use deep clone\n * e.g.\n * clone({a: 1})\n * clone({a: b: {c : 1}}, false);\n */\nfunction clone(sth, deep) {\n  if ( deep === void 0 ) deep = true;\n\n  if (isArr(sth)) {\n    return extend(deep, [], sth);\n  } else if ('' + sth === 'null') {\n    return sth;\n  } else if (isPlainObject(sth)) {\n    return extend(deep, {}, sth);\n  } else {\n    return sth;\n  }\n}\n\nvar WEAPP_APP_LIFECYCLE = ['onLaunch', 'onShow', 'onHide', 'onError', 'onPageNotFound'];\n\nvar WEAPP_PAGE_LIFECYCLE = [\n  'onLoad',\n  'onShow',\n  'onReady',\n  'onHide',\n  'onUnload',\n  'onPullDownRefresh',\n  'onReachBottom',\n  'onShareAppMessage',\n  'onPageScroll',\n  'onTabItemTap',\n  'onResize'\n];\n\nvar WEAPP_COMPONENT_LIFECYCLE = ['beforeCreate', 'created', 'attached', 'ready', 'moved', 'detached'];\n\nvar WEAPP_LIFECYCLE = []\n  .concat(WEAPP_APP_LIFECYCLE)\n  .concat(WEAPP_PAGE_LIFECYCLE)\n  .concat(WEAPP_COMPONENT_LIFECYCLE);\n\nvar config = {};\n\nvar warn = noop;\n\nvar generateComponentTrace = function(vm) {\n  return (\"Found in component: \\\"\" + (vm.$is) + \"\\\"\");\n};\n\n{\n  var hasConsole = typeof console !== 'undefined';\n  // TODO\n  warn = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      // eslint-disable-next-line\n      console.error(\"[WePY warn]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n}\n\nfunction handleError(err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while ((cur = cur.$parent)) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) { return; }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined') {\n    // eslint-disable-next-line\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both micro and macro tasks.\n// In < 2.4 we used micro tasks everywhere, but there are some scenarios where\n// micro tasks have too high a priority and fires in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using macro tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use micro task by default, but expose a way to force macro task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) Task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else if (\n  /* eslint-disable no-undef */\n  typeof MessageChannel !== 'undefined' &&\n  (isNative(MessageChannel) ||\n    // PhantomJS\n    MessageChannel.toString() === '[object MessageChannelConstructor]')\n) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function () {\n    port.postMessage(1);\n  };\n  /* eslint-enable no-undef */\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine MicroTask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    // if (isIOS) setTimeout(noop)\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n\nvar renderCallbacks = [];\n\nfunction renderFlushCallbacks() {\n  var copies = renderCallbacks.slice(0);\n  renderCallbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\nfunction renderNextTick(cb, ctx) {\n  var _resolve;\n  renderCallbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function(obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return; }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n// import type Watcher from './watcher'\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/**\n * @desc ObserverPath 类以及相关处理函数\n * Observer 所在位置对应在整棵 data tree 的路径集合\n * @createDate 2019-07-21\n */\n\n/**\n * 生成完整路径\n * @param key  {String|Number} 当为字符串时，说明是属性名，当为数字时，说明是索引\n * @param parentPath {String} 父路径\n * @return {string}\n */\nvar setPath = function (key, parentPath) {\n  return isNum(key) ? (parentPath + \"[\" + key + \"]\") : (parentPath + \".\" + key);\n};\n\n/**\n * 得到 ObserverPath\n * @param value 被观察对象\n * @return {ObserverPath|null}\n */\nvar pickOp = function (value) {\n  return isObject(value) && hasOwn(value, '__ob__') ? value.__ob__.op : null;\n};\n\nvar ObserverPath = function ObserverPath(key, ob, parentOp) {\n  this.ob = ob;\n  // eslint-disable-next-line eqeqeq\n  if (parentOp) {\n    var ref = getPathMap(key, parentOp.pathKeys, parentOp.pathMap);\n    var combinePathKeys = ref.combinePathKeys;\n    var combinePathMap = ref.combinePathMap;\n    this.pathKeys = combinePathKeys;\n    this.pathMap = combinePathMap;\n  } else {\n    this.pathKeys = null;\n    this.pathMap = null;\n  }\n};\n\nObserverPath.prototype.traverseOp = function traverseOp (key, pathKeys, pathMap, handler) {\n  // 得到 newKey 和 pathMap 组合的路径集合\n  var ref = getPathMap(key, pathKeys, pathMap);\n    var combinePathMap = ref.combinePathMap;\n    var combinePathKeys = ref.combinePathKeys;\n  var handlePathKeys = [];\n  var handlePathMap = {};\n  var hasChange = false;\n\n  // 遍历 combinePathMap\n  for (var i = 0; i < combinePathKeys.length; i++) {\n    var pathObj = handler(combinePathMap[combinePathKeys[i]], this);\n    if (pathObj) {\n      hasChange = true;\n      handlePathKeys.push(pathObj.path);\n      handlePathMap[pathObj.path] = pathObj;\n    }\n  }\n\n  if (hasChange) {\n    var value = this.ob.value;\n    if (Array.isArray(value)) {\n      for (var i$1 = 0; i$1 < value.length; i$1++) {\n        var op = pickOp(value[i$1]);\n        op && op.traverseOp(i$1, handlePathKeys, handlePathMap, handler);\n      }\n    } else {\n      var keys = Object.keys(value);\n      for (var i$2 = 0; i$2 < keys.length; i$2++) {\n        var key$1 = keys[i$2];\n        var op$1 = pickOp(value[key$1]);\n        op$1 && op$1.traverseOp(key$1, handlePathKeys, handlePathMap, handler);\n      }\n    }\n  }\n};\n\nObserverPath.prototype.addPath = function addPath (pathObj) {\n  this.pathKeys.push(pathObj.path);\n  this.pathMap[pathObj.path] = pathObj;\n};\n\nObserverPath.prototype.delPath = function delPath (path) {\n  remove(this.pathKeys, path);\n  delete this.pathMap[path];\n};\n\n/**\n * 添加新的 __ob__ 的 path\n */\nfunction addPaths(newKey, op, parentOp) {\n  op.traverseOp(newKey, parentOp.pathKeys, parentOp.pathMap, handler);\n\n  function handler(pathObj, op) {\n    if (!(pathObj.path in op.pathMap)) {\n      // 新增一条 path\n      op.addPath(pathObj);\n      return pathObj;\n    } else {\n      return null;\n    }\n  }\n}\n\n/**\n * 删除指定的 __ob__ 的 path\n */\nfunction cleanPaths(oldKey, op, parentOp) {\n  op.traverseOp(oldKey, parentOp.pathKeys, parentOp.pathMap, handler);\n\n  function handler(pathObj, op) {\n    // 删除一条 path\n    op.delPath(pathObj.path);\n    return pathObj;\n  }\n}\n\n/**\n * 得到 pathMap 与 key 组合后的路径集合\n */\nfunction getPathMap(key, pathKeys, pathMap) {\n  var obj;\n\n  if (pathMap) {\n    // console.log('pathMap', pathMap)\n    var combinePathKeys = [];\n    var combinePathMap = {};\n    for (var i = 0; i < pathKeys.length; i++) {\n      var path = setPath(key, pathMap[pathKeys[i]].path);\n      combinePathKeys.push(path);\n      combinePathMap[path] = { key: key, root: pathMap[pathKeys[i]].root, path: path };\n    }\n    return { combinePathKeys: combinePathKeys, combinePathMap: combinePathMap };\n  } else {\n    return {\n      combinePathKeys: [key],\n      combinePathMap: ( obj = {}, obj[key] = { key: key, root: key, path: key }, obj)\n    };\n  }\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function(method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [], len$1 = arguments.length;\n    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];\n\n    var len = this.length;\n    // 清除已经失效的 paths\n    if (len > 0) {\n      switch (method) {\n        case 'pop':\n          delInvalidPaths(len - 1, this[len - 1], this);\n          break;\n        case 'shift':\n          delInvalidPaths(0, this[0], this);\n          break;\n        case 'splice':\n        case 'sort':\n        case 'reverse':\n          for (var i = 0; i < this.length; i++) {\n            delInvalidPaths(i, this[i], this);\n          }\n      }\n    }\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var vm = ob.vm;\n\n    // push parent key to dirty, wait to setData\n    if (vm.$dirty) {\n      if (method === 'push') {\n        var lastIndex = ob.value.length - 1;\n        vm.$dirty.set(ob.op, lastIndex, ob.value[lastIndex]);\n      } else {\n        vm.$dirty.set(ob.op, null, ob.value);\n      }\n    }\n\n    // 这里和 vue 不一样，所有变异方法都需要更新 path\n    ob.observeArray(ob.key, ob.value);\n\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\nfunction delInvalidPaths(key, value, parent) {\n  if (isObject(value) && hasOwn(value, '__ob__')) {\n    // delete invalid paths\n    cleanPaths(key, value.__ob__.op, parent.__ob__.op);\n  }\n}\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(ref) {\n  var vm = ref.vm;\n  var key = ref.key;\n  var value = ref.value;\n  var parent = ref.parent;\n\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  this.vm = vm;\n  this.op = new ObserverPath(key, this, parent && parent.__ob__ && parent.__ob__.op);\n\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(key, value);\n  } else {\n    this.walk(key, value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (key, obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive({ vm: this.vm, obj: obj, key: keys[i], value: obj[keys[i]], parent: obj });\n    //defineReactive(this.vm, obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (key, items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe({ vm: this.vm, key: i, value: items[i], parent: items });\n  }\n};\n\n/**\n * Check if path exsit in vm\n */\nObserver.prototype.hasPath = function hasPath (path) {\n  var value = this.vm;\n  var key = '';\n  var i = 0;\n  while (i < path.length) {\n    if (path[i] !== '.' && path[i] !== '[' && path[i] !== ']') {\n      key += path[i];\n    } else if (key.length !== 0) {\n      value = value[key];\n      key = '';\n      if (!isObject(value)) {\n        return false;\n      }\n    }\n    i++;\n  }\n  return true;\n};\n\n/**\n * Is this path value equal\n */\nObserver.prototype.isPathEq = function isPathEq (path, value) {\n  var objValue = this.vm;\n  var key = '';\n  var i = 0;\n  while (i < path.length) {\n    if (path[i] !== '.' && path[i] !== '[' && path[i] !== ']') {\n      key += path[i];\n    } else if (key.length !== 0) {\n      objValue = objValue[key];\n      key = '';\n      if (!isObject(objValue)) {\n        return false;\n      }\n    }\n    i++;\n  }\n  if (key.length !== 0) {\n    objValue = objValue[key];\n  }\n  return value === objValue;\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(ref) {\n  var vm = ref.vm;\n  var key = ref.key;\n  var value = ref.value;\n  var parent = ref.parent;\n  var root = ref.root;\n\n  if (!isObject(value)) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n    var op = ob.op;\n    addPaths(key, op, parent.__ob__.op);\n  } else if (\n    observerState.shouldConvert &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer({ vm: vm, key: key, value: value, parent: parent });\n  }\n  if (root && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive(ref) {\n  var vm = ref.vm;\n  var obj = ref.obj;\n  var key = ref.key;\n  var value = ref.value;\n  var parent = ref.parent;\n  var customSetter = ref.customSetter;\n  var shallow = ref.shallow;\n\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  if (!getter && arguments.length === 2) {\n    value = obj[key];\n  }\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe({ vm: vm, key: key, value: value, parent: obj });\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var val = getter ? getter.call(obj) : value;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(val)) {\n            dependArray(val);\n          }\n        }\n      }\n      return val;\n    },\n    set: function reactiveSetter(newVal) {\n      var val = getter ? getter.call(obj) : value;\n      /* eslint-disable no-self-compare */\n      if (newVal === val || (newVal !== newVal && val !== val)) {\n        return;\n      }\n\n      if (isObject(value) && hasOwn(value, '__ob__')) {\n        /**\n         * 删掉无效的 paths\n         * 注意：即使 path 只有一个也要删掉，因为其子节点可能有多个 path\n         */\n        cleanPaths(key, value.__ob__.op, parent.__ob__.op);\n      }\n\n      /* eslint-enable no-self-compare */\n      if (\"development\" !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        value = newVal;\n      }\n\n      // Have to set dirty after value assigned, otherwise the dirty key is incrrect.\n      if (vm) {\n        // push parent key to dirty, wait to setData\n        if (vm.$dirty) {\n          vm.$dirty.set(obj.__ob__.op, key, newVal);\n        }\n      }\n      childOb = !shallow && observe({ vm: vm, key: key, value: newVal, parent: parent });\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(vm, target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' &&\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n          'at runtime - declare it upfront in the data option.'\n      );\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  if (isObject(target[key]) && hasOwn(target[key], '__ob__')) {\n    // delete invalid paths\n    cleanPaths(key, target[key].__ob__.op, ob.op);\n  }\n  defineReactive({ vm: vm, obj: ob.value, key: key, value: val, parent: ob.value });\n  if (vm) {\n    // push parent key to dirty, wait to setData\n    if (vm.$dirty && hasOwn(target, '__ob__')) {\n      vm.$dirty.set(target.__ob__.op, key, val);\n    }\n  }\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' &&\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  // set $dirty\n  target[key] = null;\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\nvar Base = function Base() {\n  this._events = {};\n  this._watchers = [];\n};\n\nBase.prototype.$set = function $set (target, key, val) {\n  return set(this, target, key, val);\n};\n\nBase.prototype.$delete = function $delete (target, key) {\n  return del(target, key);\n};\n\nBase.prototype.$on = function $on (event, fn) {\n    var this$1 = this;\n\n  if (isArr(event)) {\n    event.forEach(function (item) {\n      if (isStr(item)) {\n        this$1.$on(item, fn);\n      } else if (isObj(item)) {\n        this$1.$on(item.event, item.fn);\n      }\n    });\n  } else {\n    (this._events[event] || (this._events[event] = [])).push(fn);\n  }\n  return this;\n};\n\nBase.prototype.$once = function $once () {};\n\nBase.prototype.$off = function $off (event, fn) {\n    var this$1 = this;\n\n  if (!event && !fn) {\n    this._events = Object.create(null);\n    return this;\n  }\n\n  if (isArr(event)) {\n    event.forEach(function (item) {\n      if (isStr(item)) {\n        this$1.$off(item, fn);\n      } else if (isObj(item)) {\n        this$1.$off(item.event, item.fn);\n      }\n    });\n    return this;\n  }\n  if (!this._events[event]) { return this; }\n\n  if (!fn) {\n    this._events[event] = null;\n    return this;\n  }\n\n  if (fn) {\n    var fns = this._events[event];\n    var i = fns.length;\n    while (i--) {\n      var tmp = fns[i];\n      if (tmp === fn || tmp.fn === fn) {\n        fns.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return this;\n};\n\nBase.prototype.$emit = function $emit (event) {\n    var this$1 = this;\n\n  var vm = this;\n  var lowerCaseEvent = event.toLowerCase();\n  var fns = this._events[event] || [];\n  if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n    // TODO: handler warn\n  }\n  var args = toArray(arguments, 1);\n  fns.forEach(function (fn) {\n    try {\n      fn.apply(this$1, args);\n    } catch (e) {\n      handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n    }\n  });\n  return this;\n};\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n//import { callHook, activateChildComponent } from '../instance/lifecycle';\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue(times) {\n  if ( times === void 0 ) times = 0;\n\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  times === 0 && queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  // there would be mutilple renderWatcher in the queue.\n  var renderWatcher = [];\n  if (times === 0) {\n    index = 0;\n  }\n  for (; index < queue.length; index++) {\n    // if it's renderWatcher, run it in the end\n    watcher = queue[index];\n    if (watcher && watcher.isRenderWatcher) {\n      renderWatcher.push(watcher);\n      continue;\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    // eslint-disable-next-line\n    if (\"development\" !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' +\n            (watcher.user ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\") : \"in a component render function.\"),\n          watcher.vm\n        );\n        resetSchedulerState();\n        return;\n      }\n    }\n  }\n  // Run renderWatcher in the end.\n  if (renderWatcher.length) {\n    renderWatcher.forEach(function (watcher) {\n      has[watcher.id] = null;\n      watcher.run();\n    });\n  }\n\n  // It may added new watcher to the queue in render watcher\n  var pendingQueue = queue.slice(index);\n\n  if (pendingQueue.length) {\n    flushSchedulerQueue(times + 1);\n  } else {\n    // keep copies of post queues before resetting state\n    // const activatedQueue = activatedChildren.slice()\n    // const updatedQueue = queue.slice()\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    // callActivatedHooks(activatedQueue)\n    // callUpdatedHooks(updatedQueue)\n\n    // devtool hook\n    /* istanbul ignore if */\n    /*\n    if (devtools && config.devtools) {\n      devtools.emit('flush')\n    }*/\n  }\n}\n\n/*\nfunction callActivatedHooks(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true);\n  }\n}\n*/\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  // eslint-disable-next-line\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n//import { SimpleSet } from '../util/index';\n\nvar uid$1 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.computed = !!options.computed;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.computed = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n  this.active = true;\n  this.dirty = this.computed; // for computed watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.isRenderWatcher = isRenderWatcher;\n  this.expression = expOrFn.toString();\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function() {};\n      \"development\" !== 'production' &&\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n            'Watcher only accepts simple dot-delimited paths. ' +\n            'For full control, use a function instead.',\n          vm\n        );\n    }\n  }\n  this.value = this.computed ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    if (!this.isRenderWatcher) { this.cleanupDeps(); }\n  }\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.computed) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for computed watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  if (this.vm.$dirty) {\n    var keyVal =\n      this._computedWatchers && this._computedWatchers[this.key]\n        ? this.vm._computedWatchers[this.key].value\n        : this.value;\n    this.vm.$dirty.push(this.key, this.key, keyVal, this.value);\n  }\n  this.dirty = false;\n  return this.value;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  if (Dep.target) {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\nvar WepyComponent = /*@__PURE__*/(function (Base$$1) {\n  function WepyComponent () {\n    Base$$1.apply(this, arguments);\n  }\n\n  if ( Base$$1 ) WepyComponent.__proto__ = Base$$1;\n  WepyComponent.prototype = Object.create( Base$$1 && Base$$1.prototype );\n  WepyComponent.prototype.constructor = WepyComponent;\n\n  WepyComponent.prototype.$watch = function $watch (expOrFn, cb, options) {\n    var this$1 = this;\n\n    var vm = this;\n    if (isArr(cb)) {\n      cb.forEach(function (handler) {\n        this$1.$watch(expOrFn, handler, options);\n      });\n    }\n    if (isPlainObject(cb)) {\n      var handler = cb;\n      options = handler;\n      handler = handler.handler;\n      if (typeof handler === 'string') { handler = this[handler]; }\n      return this.$watch(expOrFn, handler, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n\n  WepyComponent.prototype.$forceUpdate = function $forceUpdate () {\n    if (this._watcher) {\n      this._watcher.update();\n    }\n  };\n\n  WepyComponent.prototype.$emit = function $emit (event) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var fns = this._events[event];\n\n    if (fns) {\n      Base$$1.prototype.$emit.apply(this, arguments);\n    } else {\n      this.$wx.triggerEvent(event, { arguments: args });\n    }\n\n    return this;\n  };\n\n  WepyComponent.prototype.$trigger = function $trigger (event, data, option) {\n    this.$wx.triggerEvent(event, { arguments: [data] }, option);\n  };\n\n  return WepyComponent;\n}(Base));\n\nWepyComponent.prototype.$nextTick = renderNextTick;\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\n/*\n * patch data option\n */\nfunction patchData(output, data) {\n  if (!data) {\n    data = {};\n  }\n  output.data = data;\n}\n\n/*\n * init data\n */\nfunction initData(vm, data) {\n  if (!data) {\n    data = {};\n  }\n  var _data;\n  if (typeof data === 'function') {\n    _data = data.call(vm);\n  } else {\n    _data = clone(data);\n  }\n  vm._data = _data;\n  Object.keys(_data).forEach(function (key) {\n    proxy(vm, '_data', key);\n  });\n\n  observe({\n    vm: vm,\n    key: '',\n    value: _data,\n    parent: '',\n    root: true\n  });\n  //observe(vm, _data, null, true);\n}\n\nfunction initWatch(vm, watch) {\n  if (watch) {\n    Object.keys(watch).forEach(function (key) {\n      vm.$watch(key, watch[key]);\n    });\n  }\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      watcher.key = key;\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\n/*\n * init computed\n */\nfunction initComputed(vm, computed) {\n  if (!computed) {\n    return;\n  }\n  var watchers = (vm._computedWatchers = Object.create(null));\n  var computedWatcherOptions = { computed: true };\n\n  Object.keys(computed).forEach(function (key) {\n    var def = computed[key];\n    var getter = typeof def === 'object' ? def.get : def;\n\n    if (!getter || typeof getter !== 'function') {\n      // eslint-disable-next-line\n      console.error((\"Getter is missing for computed property \\\"\" + key + \"\\\"\"));\n    }\n\n    // push to dirty after dep called.\n    watchers[key] = new Watcher(\n      vm,\n      getter || function() {},\n      function() {\n        // evaluate will set dirty\n        // vm.$dirty.push(key, key, newv);\n      },\n      computedWatcherOptions\n    );\n\n    if (typeof def === 'function') {\n      sharedPropertyDefinition.get = createComputedGetter(key);\n      sharedPropertyDefinition.set = function() {};\n    } else {\n      sharedPropertyDefinition.get = def.cache !== false ? createComputedGetter(key) : def.get;\n      sharedPropertyDefinition.set = def.set;\n    }\n\n    Object.defineProperty(vm, key, sharedPropertyDefinition);\n  });\n}\n\nvar WepyConstructor = /*@__PURE__*/(function (WepyComponent$$1) {\n  function WepyConstructor(opt) {\n    if ( opt === void 0 ) opt = {};\n\n    WepyComponent$$1.call(this);\n    var vm = new WepyComponent$$1();\n\n    // Only need data and watchers for a empty WepyComponent\n    if (opt.data) {\n      initData(vm, opt.data);\n    }\n    initWatch(vm);\n\n    initComputed(vm, opt.computed);\n    return vm;\n  }\n\n  if ( WepyComponent$$1 ) WepyConstructor.__proto__ = WepyComponent$$1;\n  WepyConstructor.prototype = Object.create( WepyComponent$$1 && WepyComponent$$1.prototype );\n  WepyConstructor.prototype.constructor = WepyConstructor;\n\n  return WepyConstructor;\n}(WepyComponent));\n\nvar $global = Object.create(null);\n\nfunction use(plugin) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  if (plugin.installed) {\n    return this;\n  }\n\n  var install = plugin.install || plugin;\n\n  if (isFunc(install)) {\n    install.apply(plugin, [this].concat(args));\n  }\n\n  plugin.installed = 1;\n}\n\nfunction mixin(options) {\n  if ( options === void 0 ) options = {};\n\n  $global.mixin = ($global.mixin || []).concat(options);\n}\n\nvar WepyApp = /*@__PURE__*/(function (Base$$1) {\n  function WepyApp() {\n    Base$$1.call(this);\n  }\n\n  if ( Base$$1 ) WepyApp.__proto__ = Base$$1;\n  WepyApp.prototype = Object.create( Base$$1 && Base$$1.prototype );\n  WepyApp.prototype.constructor = WepyApp;\n\n  return WepyApp;\n}(Base));\n\nvar WepyPage = /*@__PURE__*/(function (WepyComponent$$1) {\n  function WepyPage () {\n    WepyComponent$$1.apply(this, arguments);\n  }\n\n  if ( WepyComponent$$1 ) WepyPage.__proto__ = WepyComponent$$1;\n  WepyPage.prototype = Object.create( WepyComponent$$1 && WepyComponent$$1.prototype );\n  WepyPage.prototype.constructor = WepyPage;\n\n  WepyPage.prototype.$launch = function $launch (url, params) {\n    this.$route('reLaunch', url, params);\n  };\n  WepyPage.prototype.$navigate = function $navigate (url, params) {\n    this.$route('navigate', url, params);\n  };\n\n  WepyPage.prototype.$redirect = function $redirect (url, params) {\n    this.$route('redirect', url, params);\n  };\n\n  WepyPage.prototype.$back = function $back (p) {\n    if ( p === void 0 ) p = {};\n\n    if (isNum(p)) { p = { delta: p }; }\n\n    if (!p.delta) { p.delta = 1; }\n\n    return wx.navigateBack(p);\n  };\n\n  WepyPage.prototype.$route = function $route (type, url, params) {\n    if ( params === void 0 ) params = {};\n\n    var wxparams;\n    if (isStr(url)) {\n      var paramsList = [];\n      if (isObj(params)) {\n        for (var k in params) {\n          if (!isUndef(params[k])) {\n            paramsList.push((k + \"=\" + (encodeURIComponent(params[k]))));\n          }\n        }\n      }\n      if (paramsList.length) { url = url + '?' + paramsList.join('&'); }\n\n      wxparams = { url: url };\n    } else {\n      wxparams = url;\n    }\n    var fn = wx[type] || wx[type + 'To'];\n    if (isFunc(fn)) {\n      return fn(wxparams);\n    }\n  };\n\n  return WepyPage;\n}(WepyComponent));\n\nfunction callUserHook(vm, hookName, arg) {\n  var pageHook = vm.hooks ? vm.hooks[hookName] : null;\n  var appHook = vm.$app && vm.$app.hooks ? vm.$app.hooks[hookName] : null;\n\n  if (!vm.$app) {\n    warn('$app is not initialized in this Component', vm);\n  }\n\n  var result = arg;\n\n  // First run page hook, and then run app hook\n  // Pass page hook result to app hook\n  // If return undefined, then return default argument\n  [pageHook, appHook].forEach(function (fn) {\n    if (isFunc(fn)) {\n      result = fn.call(vm, result);\n      if (isUndef(result)) {\n        result = arg;\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction initHooks(vm, hooks) {\n  if ( hooks === void 0 ) hooks = {};\n\n  vm.hooks = hooks;\n}\n\nvar AllowedTypes = [String, Number, Boolean, Object, Array, null];\n\nvar observerFn = function() {\n  return function(newVal, oldVal, changedPaths) {\n    var vm = this.$wepy;\n\n    // changedPaths 长度大于 1，说明是由内部赋值改变的 prop\n    if (changedPaths.length > 1) {\n      return;\n    }\n    var _data = newVal;\n    if (typeof _data === 'function') {\n      _data = _data.call(vm);\n    }\n    vm[changedPaths[0]] = _data;\n  };\n};\n/*\n * patch props option\n */\nfunction patchProps(output, props) {\n  var newProps = {};\n  if (isStr(props)) {\n    newProps = [props];\n  }\n  if (isArr(props)) {\n    props.forEach(function (prop) {\n      newProps[prop] = {\n        type: null,\n        observer: observerFn(output, props, prop)\n      };\n    });\n  } else if (isObj(props)) {\n    for (var k in props) {\n      var prop = props[k];\n      var newProp = {};\n\n      // props.type\n      if (isUndef(prop.type)) {\n        newProp.type = null;\n      } else if (isArr(prop.type)) {\n        newProp.type = null;\n        // eslint-disable-next-line\n        console.warn((\"In mini-app, mutiple type is not allowed. The type of \\\"\" + k + \"\\\" will changed to \\\"null\\\"\"));\n      } else if (AllowedTypes.indexOf(prop.type) === -1) {\n        newProp.type = null;\n        // eslint-disable-next-line\n        console.warn(\n          (\"Type property of props \\\"\" + k + \"\\\" is invalid. Only String/Number/Boolean/Object/Array/null is allowed in weapp Component\")\n        );\n      } else {\n        newProp.type = prop.type;\n      }\n\n      // props.default\n      if (!isUndef(prop.default)) {\n        if (isFunc(prop.default)) {\n          newProp.value = prop.default.call(output);\n        } else {\n          newProp.value = prop.default;\n        }\n      }\n      // TODO\n      // props.validator\n      // props.required\n\n      newProp.observer = observerFn(output, props, prop);\n\n      newProps[k] = newProp;\n    }\n  }\n\n  // eslint-disable-next-line\n  Object.keys(newProps).forEach(function (prop) {});\n\n  output.properties = newProps;\n}\n\n/*\n * init props\n */\nfunction initProps(vm, properties) {\n  vm._props = {};\n\n  if (!properties) {\n    return;\n  }\n\n  Object.keys(properties).forEach(function (key) {\n    vm._props[key] = properties[key].value;\n    proxy(vm, '_props', key);\n  });\n\n  observe({\n    vm: vm,\n    key: '',\n    value: vm._props,\n    root: true\n  });\n}\n\nfunction initRender(vm, keys, computedKeys) {\n  vm._init = false;\n  var dirtyFromAttach = null;\n  return new Watcher(\n    vm,\n    function() {\n      if (!vm._init) {\n        keys.forEach(function (key) { return clone(vm[key]); });\n      }\n\n      if (vm.$dirty.length() || dirtyFromAttach) {\n        var keys$1 = vm.$dirty.get('key');\n        computedKeys.forEach(function (key) { return vm[key]; });\n        var dirty = vm.$dirty.pop();\n\n        // TODO: reset subs\n        Object.keys(keys$1).forEach(function (key) { return clone(vm[key]); });\n\n        if (vm._init) {\n          dirty = callUserHook(vm, 'before-setData', dirty);\n        }\n\n        // vm._fromSelf = true;\n        if (dirty || dirtyFromAttach) {\n          // init render is in lifecycle, setData in lifecycle will not work, so cacheData is needed.\n          if (!vm._init) {\n            if (dirtyFromAttach === null) {\n              dirtyFromAttach = {};\n            }\n            Object.assign(dirtyFromAttach, dirty);\n          } else if (dirtyFromAttach) {\n            // setData in attached\n            vm.$wx.setData(Object.assign(dirtyFromAttach, dirty || {}), renderFlushCallbacks);\n            dirtyFromAttach = null;\n          } else {\n            vm.$wx.setData(dirty, renderFlushCallbacks);\n          }\n        }\n      }\n      vm._init = true;\n    },\n    function() {},\n    null,\n    true\n  );\n}\n\nvar Event = function Event(e) {\n  var detail = e.detail;\n  var target = e.target;\n  var currentTarget = e.currentTarget;\n  this.$wx = e;\n  this.type = e.type;\n  this.timeStamp = e.timeStamp;\n  if (detail) {\n    this.x = detail.x;\n    this.y = detail.y;\n  }\n\n  this.target = target;\n  this.currentTarget = currentTarget;\n  this.touches = e.touches;\n  this.changedTouches = e.changedTouches;\n};\n\n/**\n * Transform wxml data-xx params to an array\n */\nfunction transformParams(dataset, type, hasModel) {\n  if ( hasModel === void 0 ) hasModel = false;\n\n  var i = 0;\n  var params = [];\n  var modelParams = [];\n\n  var noParams = false;\n  var noModelParams = !hasModel;\n\n  var camelizedType = camelize(type);\n  while (i++ < 26 && (!noParams || !noModelParams)) {\n    var alpha = String.fromCharCode(64 + i);\n    if (!noParams) {\n      var key = 'wpy' + camelizedType + alpha;\n      if (!(key in dataset)) {\n        // it can be undefined;\n        noParams = true;\n      } else {\n        params.push(dataset[key]);\n      }\n    }\n    if (!noModelParams && hasModel) {\n      var modelKey = 'model' + alpha;\n      if (!(modelKey in dataset)) {\n        noModelParams = true;\n      } else {\n        modelParams.push(dataset[modelKey]);\n      }\n    }\n  }\n\n  return {\n    handler: params,\n    model: modelParams\n  };\n}\n\nvar dispatcher = function(e) {\n  var vm = this.$wepy;\n  var type = e.type;\n  // touchstart do not have currentTarget\n  var dataset = (e.currentTarget || e.target).dataset || {};\n  var evtid = dataset.wpyEvt;\n  var modelId = dataset.modelId;\n  var rel = vm.$rel || {};\n  var handler = rel.handlers && rel.handlers[evtid] && rel.handlers[evtid][type];\n  var model = rel.models && rel.models[modelId];\n\n  if (!handler && !model) {\n    return;\n  }\n\n  var params = transformParams(dataset, type, !!model);\n\n  // Call model method\n  if (model && type === model.type && isFunc(model.handler)) {\n    model.handler.call(vm, e.detail.value, params.model);\n  }\n\n  // Call handler method\n  if (isFunc(handler)) {\n    var $event = new Event(e);\n    var paramsWithEvent = params.handler.concat($event);\n    var args = (e.detail && e.detail.arguments) || [];\n\n    var hookRes = callUserHook(vm, 'before-event', {\n      event: $event,\n      params: paramsWithEvent,\n      args: args\n    });\n\n    if (hookRes === false) {\n      // Event cancelled.\n      return;\n    }\n    return handler.apply(vm, paramsWithEvent);\n  } else if (!model) {\n    throw new Error('Unrecognized event');\n  }\n};\n\n/*\n * initialize page methods, also the app\n */\nfunction initMethods(vm, methods) {\n  if (methods) {\n    Object.keys(methods).forEach(function (method) {\n      vm[method] = methods[method];\n    });\n  }\n}\n\n/*\n * patch method option\n */\nfunction patchMethods(output, methods) {\n  output.methods = {};\n  var target = output.methods;\n\n  target.__initComponent = function(e) {\n    var child = e.detail;\n    var ref$1 = e.target.dataset;\n    var ref = ref$1.ref;\n    var wpyEvt = ref$1.wpyEvt;\n    var vm = this.$wepy;\n    vm.$children.push(child);\n    if (ref) {\n      if (vm.$refs[ref]) {\n        warn('duplicate ref \"' + ref + '\" will be covered by the last instance.\\n', vm);\n      }\n      vm.$refs[ref] = child;\n    }\n    child.$evtId = wpyEvt;\n    child.$parent = vm;\n    child.$app = vm.$app;\n    child.$root = vm.$root;\n    return vm;\n  };\n  target.__dispatcher = dispatcher;\n\n  // TODO: perf\n  // Only orginal component method goes to target. no need to add all methods.\n  if (methods) {\n    Object.keys(methods).forEach(function (method) {\n      target[method] = methods[method];\n    });\n  }\n}\n\nvar Dirty = function Dirty(type) {\n  this.reset();\n\n  // path||key\n  this.type = type || 'path';\n};\n\nDirty.prototype.push = function push (key, path, keyValue, pathValue) {\n  if (pathValue === undefined) {\n    return;\n  }\n  this._keys[key] = keyValue;\n  this._path[path] = pathValue;\n  this._length++;\n};\n\nDirty.prototype.pop = function pop () {\n  var data = Object.create(null);\n  if (this.type === 'path') {\n    data = this._path;\n  } else if (this.type === 'key') {\n    data = this._keys;\n  }\n  this.reset();\n  return data;\n};\n\nDirty.prototype.get = function get (type) {\n  return type === 'path' ? this._path : this._keys;\n};\n\n/**\n * Set dirty from a ObserverPath\n */\nDirty.prototype.set = function set (op, key, value) {\n  var pathMap;\n  var pathKeys;\n  // eslint-disable-next-line eqeqeq\n  if (key != null) {\n    var ref = getPathMap(key, op.pathKeys, op.pathMap);\n      var combinePathKeys = ref.combinePathKeys;\n      var combinePathMap = ref.combinePathMap;\n    pathKeys = combinePathKeys;\n    pathMap = combinePathMap;\n  } else {\n    pathKeys = op.pathKeys;\n    pathMap = op.pathMap;\n  }\n  /**\n   * 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，\n   * 即 this.setData({ field: obj }) 后 this.data.field === obj 。\n   * 因此不需要所有 path 都 setData 。\n   */\n  var ref$1 = pathMap[pathKeys[0]];\n    var root = ref$1.root;\n    var path = ref$1.path;\n  this.push(root, path, root === path ? value : op.ob.vm[root], value);\n};\n\nDirty.prototype.reset = function reset () {\n  this._keys = {};\n  this._path = {};\n  this._length = 0;\n  return this;\n};\n\nDirty.prototype.length = function length () {\n  return this._length;\n};\n\nvar comid = 0;\nvar app;\n\nvar callUserMethod = function(vm, userOpt, method, args) {\n  var result;\n  var methods = userOpt[method];\n  if (isFunc(methods)) {\n    result = userOpt[method].apply(vm, args);\n  } else if (isArr(methods)) {\n    for (var i in methods) {\n      if (isFunc(methods[i])) {\n        result = methods[i].apply(vm, args);\n      }\n    }\n  }\n  return result;\n};\n\nvar getLifecycycle = function (defaultLifecycle, rel, type) {\n  var lifecycle = defaultLifecycle.concat([]);\n  if (rel && rel.lifecycle && rel.lifecycle[type]) {\n    var userDefinedLifecycle = [];\n    if (isFunc(rel.lifecycle[type])) {\n      userDefinedLifecycle = rel.lifecycle[type].call(null, lifecycle);\n    }\n    userDefinedLifecycle.forEach(function (u) {\n      if (lifecycle.indexOf(u) > -1) {\n        warn((\"'\" + u + \"' is already implemented in current version, please remove it from your lifecycel config\"));\n      } else {\n        lifecycle.push(u);\n      }\n    });\n  }\n  return lifecycle;\n};\n\n/*\n * patch app lifecyle\n */\nfunction patchAppLifecycle(appConfig, options, rel) {\n  if ( rel === void 0 ) rel = {};\n\n  appConfig.onLaunch = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var vm = new WepyApp();\n    app = vm;\n    vm.$options = options;\n    vm.$route = {};\n    vm.$rel = rel;\n\n    vm.$wx = this;\n    this.$wepy = vm;\n\n    initHooks(vm, options.hooks);\n\n    initMethods(vm, options.methods);\n\n    return callUserMethod(vm, vm.$options, 'onLaunch', args);\n  };\n\n  var lifecycle = getLifecycycle(WEAPP_APP_LIFECYCLE, rel, 'app');\n\n  lifecycle.forEach(function (k) {\n    // it's not defined aready && user defined it && it's an array or function\n    if (!appConfig[k] && options[k] && (isFunc(options[k]) || isArr(options[k]))) {\n      appConfig[k] = function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return callUserMethod(app, app.$options, k, args);\n      };\n    }\n  });\n}\n\nfunction patchLifecycle(output, options, rel, isComponent) {\n  var initClass = isComponent ? WepyComponent : WepyPage;\n  var initLifecycle = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var vm = new initClass();\n\n    vm.$dirty = new Dirty('path');\n    vm.$children = [];\n    vm.$refs = {};\n\n    this.$wepy = vm;\n    vm.$wx = this;\n    vm.$is = this.is;\n    vm.$options = options;\n    vm.$rel = rel;\n    vm._watchers = [];\n    if (!isComponent) {\n      vm.$root = vm;\n    }\n    if (app) {\n      vm.$app = app;\n    }\n    if (this.is === 'custom-tab-bar/index') {\n      vm.$app = app;\n      vm.$parent = app;\n    }\n\n    vm.$id = ++comid + (isComponent ? '.1' : '.0');\n\n    callUserMethod(vm, vm.$options, 'beforeCreate', args);\n\n    initHooks(vm, options.hooks);\n\n    initProps(vm, output.properties);\n\n    initData(vm, output.data, isComponent);\n\n    initMethods(vm, options.methods);\n\n    initComputed(vm, options.computed, true);\n\n    initWatch(vm, options.watch);\n\n    // create render watcher\n    initRender(\n      vm,\n      Object.keys(vm._data)\n        .concat(Object.keys(vm._props))\n        .concat(Object.keys(vm._computedWatchers || {})),\n      Object.keys(vm._computedWatchers || {})\n    );\n\n    return callUserMethod(vm, vm.$options, 'created', args);\n  };\n\n  output.created = initLifecycle;\n  if (isComponent) {\n    output.attached = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Component attached\n      var outProps = output.properties || {};\n      // this.propperties are includes datas\n      var acceptProps = this.properties;\n      var vm = this.$wepy;\n\n      this.triggerEvent('_init', vm);\n\n      // created 不能调用 setData，如果有 dirty 在此更新\n      vm.$forceUpdate();\n\n      Object.keys(outProps).forEach(function (k) { return (vm[k] = acceptProps[k]); });\n\n      return callUserMethod(vm, vm.$options, 'attached', args);\n    };\n  } else {\n    output.attached = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Page attached\n      var vm = this.$wepy;\n      var app = vm.$app;\n      // eslint-disable-next-line\n      var pages = getCurrentPages();\n      var currentPage = pages[pages.length - 1];\n      var path = currentPage.__route__;\n      var webViewId = currentPage.__wxWebviewId__;\n\n      var refs = rel.refs || [];\n      var query = wx.createSelectorQuery();\n\n      refs.forEach(function (item) {\n        // {\n        //   id: { name: 'hello', bind: true },\n        //   ref: { name: 'value', bind: false }\n        // }\n        var idAttr = item.id;\n        var refAttr = item.ref;\n        var actualAttrIdName = idAttr.name;\n        var actualAttrRefName = refAttr.name;\n        var selector = \"#\" + actualAttrIdName;\n\n        if (idAttr.bind) {\n          // if id is a bind attr\n          actualAttrIdName = vm[idAttr.name];\n          selector = \"#\" + actualAttrIdName;\n          vm.$watch(idAttr.name, function(newAttrName) {\n            actualAttrIdName = newAttrName;\n            selector = \"#\" + actualAttrIdName;\n            vm.$refs[actualAttrRefName] = query.select(selector);\n          });\n        }\n\n        if (refAttr.bind) {\n          // if ref is a bind attr\n          actualAttrRefName = vm[refAttr.name];\n\n          vm.$watch(refAttr.name, function(newAttrName, oldAttrName) {\n            actualAttrRefName = newAttrName;\n            vm.$refs[oldAttrName] = null;\n            vm.$refs[newAttrName] = query.select(selector);\n          });\n        }\n        vm.$refs[actualAttrRefName] = query.select(selector);\n      });\n\n      // created 不能调用 setData，如果有 dirty 在此更新\n      vm.$forceUpdate();\n\n      if (app.$route.path !== path) {\n        app.$route.path = path;\n        app.$route.webViewId = webViewId;\n        vm.routed && vm.routed();\n      }\n\n      // TODO: page attached\n      return callUserMethod(vm, vm.$options, 'attached', args);\n    };\n    // Page lifecycle will be called under methods\n    // e.g:\n    // Component({\n    //   methods: {\n    //     onLoad () {\n    //       console.log('page onload')\n    //     }\n    //   }\n    // })\n\n    var lifecycle$1 = getLifecycycle(WEAPP_PAGE_LIFECYCLE, rel, 'page');\n\n    lifecycle$1.forEach(function (k) {\n      if (!output[k] && options[k] && (isFunc(options[k]) || isArr(options[k]))) {\n        output.methods[k] = function() {\n          var args = [], len = arguments.length;\n          while ( len-- ) args[ len ] = arguments[ len ];\n\n          return callUserMethod(this.$wepy, this.$wepy.$options, k, args);\n        };\n      }\n    });\n  }\n  var lifecycle = getLifecycycle(WEAPP_COMPONENT_LIFECYCLE, rel, 'component');\n\n  lifecycle.forEach(function (k) {\n    // beforeCreate is not a real lifecycle\n    if (!output[k] && k !== 'beforeCreate' && (isFunc(options[k]) || isArr(options[k]))) {\n      output[k] = function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return callUserMethod(this.$wepy, this.$wepy.$options, k, args);\n      };\n    }\n  });\n}\n\nvar config$1 = {\n  optionMergeStrategies: {},\n  constants: {\n    WEAPP_LIFECYCLE: WEAPP_LIFECYCLE,\n    WEAPP_APP_LIFECYCLE: WEAPP_APP_LIFECYCLE,\n    WEAPP_PAGE_LIFECYCLE: WEAPP_PAGE_LIFECYCLE,\n    WEAPP_COMPONENT_LIFECYCLE: WEAPP_COMPONENT_LIFECYCLE\n  }\n};\n\n// [Default Strategy]\n// Update if it's not exist in output. Can be replaced by option[key].\n// e.g.\n// export default {\n//   myCustomMethod () {\n//     // doSomething\n//   }\n// }\n//\n// [Merge Strategy]\n// Replaced by the latest mixins property.\n// e.g.\n// export default {\n//   data: {\n//     a: 1\n//   }\n// }\n//\n// [Lifecycle Strategy]\n// Extend lifecycle. update lifecycle to an array.\n// e.g.\n// export default {\n//   onShow: {\n//     console.log('onShow');\n//   }\n// }\nvar globalMixinPatched = false;\n\nvar strats = null;\n\nfunction getStrategy(key) {\n  if (!strats) {\n    initStrats();\n  }\n  if (strats[key]) {\n    return strats[key];\n  } else {\n    return defaultStrat;\n  }\n}\nfunction defaultStrat(output, option, key, data) {\n  if (!output[key]) {\n    output[key] = data;\n  }\n}\n\nfunction simpleMerge(parentVal, childVal) {\n  return !parentVal || !childVal ? parentVal || childVal : Object.assign({}, parentVal, childVal);\n}\n\nfunction initStrats() {\n  if (strats) { return strats; }\n\n  strats = config$1.optionMergeStrategies;\n\n  strats.data = strats.props = strats.methods = strats.computed = strats.watch = strats.hooks = function mergeStrategy(\n    output,\n    option,\n    key,\n    data\n  ) {\n    option[key] = simpleMerge(option[key], data);\n  };\n\n  WEAPP_LIFECYCLE.forEach(function (lifecycle) {\n    if (!strats[lifecycle]) {\n      strats[lifecycle] = function lifeCycleStrategy(output, option, key, data) {\n        if (!option[key]) {\n          option[key] = isArr(data) ? data : [data];\n        } else {\n          option[key] = [data].concat(option[key]);\n        }\n      };\n    }\n  });\n}\n\nfunction patchMixins(output, option, mixins) {\n  if (!mixins && !$global.mixin) {\n    return;\n  }\n\n  if (!globalMixinPatched) {\n    var globalMixin = $global.mixin || [];\n\n    mixins = globalMixin.concat(mixins);\n    globalMixinPatched = true;\n  }\n\n  if (isArr(mixins)) {\n    mixins.forEach(function (mixin) { return patchMixins(output, option, mixin); });\n    globalMixinPatched = false;\n  } else {\n    if (!strats) {\n      initStrats();\n    }\n    for (var k in mixins) {\n      strat = getStrategy(k);\n      var strat = strats[k] || defaultStrat;\n      strat(output, option, k, mixins[k]);\n    }\n  }\n}\n\nfunction patchRelations(output, relations) {\n  if (!relations) {\n    relations = {};\n  }\n  output.relations = relations;\n}\n\nfunction app$1(option, rel) {\n  var appConfig = {};\n\n  patchMixins(appConfig, option, option.mixins);\n  patchAppLifecycle(appConfig, option, rel);\n\n  return App(appConfig);\n}\n\nfunction component(opt, rel) {\n  if ( opt === void 0 ) opt = {};\n\n  var compConfig = {\n    externalClasses: opt.externalClasses || [],\n    // support component options property\n    // example: options: {addGlobalClass:true}\n    options: opt.options || {}\n  };\n\n  patchMixins(compConfig, opt, opt.mixins);\n\n  if (opt.properties) {\n    compConfig.properties = opt.properties;\n    if (opt.props) {\n      // eslint-disable-next-line no-console\n      console.warn(\"props will be ignore, if properties is set\");\n    }\n  } else if (opt.props) {\n    patchProps(compConfig, opt.props);\n  }\n\n  patchMethods(compConfig, opt.methods, true);\n\n  patchData(compConfig, opt.data, true);\n\n  patchRelations(compConfig, opt.relations);\n\n  patchLifecycle(compConfig, opt, rel, true);\n\n  return Component(compConfig);\n}\n\nfunction page(opt, rel) {\n  if ( opt === void 0 ) opt = {};\n\n  var pageConfig = {\n    externalClasses: opt.externalClasses || [],\n    // support component options property\n    // example: options: {addGlobalClass:true}\n    options: opt.options || {}\n  };\n\n  patchMixins(pageConfig, opt, opt.mixins);\n\n  if (opt.properties) {\n    pageConfig.properties = opt.properties;\n    if (opt.props) {\n      // eslint-disable-next-line\n      console.warn(\"props will be ignore, if properties is set\");\n    }\n  } else if (opt.props) {\n    patchProps(pageConfig, opt.props);\n  }\n\n  patchMethods(pageConfig, opt.methods);\n\n  patchData(pageConfig, opt.data);\n\n  patchLifecycle(pageConfig, opt, rel);\n\n  return Component(pageConfig);\n}\n\nfunction initGlobalAPI(wepy) {\n  wepy.use = use;\n  wepy.mixin = mixin;\n\n  wepy.set = function(target, key, val) {\n    set.apply(wepy, [undefined, target, key, val]);\n  };\n\n  wepy.delete = del;\n\n  wepy.observe = observe;\n\n  wepy.nextTick = renderNextTick;\n\n  wepy.app = app$1;\n  wepy.page = page;\n  wepy.component = component;\n\n  return wepy;\n}\n\nvar wepy = initGlobalAPI(WepyConstructor);\n\nwepy.config = config$1;\nwepy.global = $global;\nwepy.version = \"2.0.0-alpha.15\";\n\nmodule.exports = wepy;\n"]}